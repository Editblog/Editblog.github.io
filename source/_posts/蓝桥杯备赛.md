# 一、独立键盘

# 1.状态机

```c
#define btn_io P3
#define btn_state_0 0	  //是否按下
#define btn_state_1 1 	 //是否是抖动
#define btn_state_2 2	  //判定按键有效的种类
#define btn_state_3 3	  //等待按键释放
#define btn_mask 0x0f	  //屏蔽不需要的IO
#define LONG_KEY_TIME 100 //LONG_KEY_TIME*10MS = 3S
#define SINGLE_KEY_TIME 3 //SINGLE_KEY_TIME*10MS = 30MS
char btnkey;
static char btn_state = 0;
char scanbtn(void)
{
	static int key_time; //按键计时变量	
	static char key_value=0;
	char btn_press,btn_return = 0;
	btn_press = btn_io & btn_mask;
	switch(btn_state)
	{
		case btn_state_0:
			key_value=0;
			if(btn_press != btn_mask){
				key_time = 0; // 清零时间间隔计数
				btn_state = btn_state_1;
			}
			break;
		case btn_state_1:
			if(btn_press != btn_mask)
			{
				key_time++; // 一次10ms
				if (key_time >= SINGLE_KEY_TIME) // 消抖时间为：SINGLE_KEY_TIME*10ms = 30ms;
				{
					btn_state = btn_state_2;
				}
			}
			else
				btn_state = btn_state_0;
			break;
		case btn_state_2:
			if(btn_press == btn_mask)
			{
				btn_return=key_value;
				key_value=0;
				btn_state = btn_state_0; // 去状态3，等待按键释放
			}
			else
			{
				if(btn_press == 0x0e) key_value = 1;
				if(btn_press == 0x0d) key_value = 2;
				if(btn_press == 0x0b) key_value = 3;
				if(btn_press == 0x07) key_value = 4;
				key_time++;
				if (key_time >= LONG_KEY_TIME) // 如果按键时间超过 设定的长按时间（LONG_KEY_TIME*10ms=200*10ms=2000ms）, 则判定为 长按
				{
					btn_return =key_value|0x80;
					key_value=0;
					btn_state = btn_state_3; // 去状态3，等待按键释放
				}
			}
			break;
		case btn_state_3:
			if(btn_press == 0x0f)	btn_state = btn_state_0;
			break;
		default:
		break;
	}
	return 	btn_return;
}
```

# 二、矩阵键盘

# 三、DS1302驱动更改

![image-20210304231254265](https://raw.githubusercontent.com/Editblog/PicGo/main/img/20210304231254.png)

```C
/**
  * @brief  无需更改延时
  * @param  shi,fen,miao
  * @retval None
  * @author dianshe.taobao.com
  */
void set_sfm(char shi,char fen,char miao)
{
	Write_Ds1302_Byte(0x8e,0);							//关闭写保护
	Write_Ds1302_Byte(0x80,(miao/10)*16+miao%10);		//以BCD码写入秒数据
	Write_Ds1302_Byte(0x82,(fen/10)*16+fen%10);			//以BCD码写入分数据
	Write_Ds1302_Byte(0x84,(shi/10)*16+shi%10);			//以BCD码写入时数据
	Write_Ds1302_Byte(0x8e,0x80);						//打开写保护
}
```

# 四、IIC驱动修改(PCF8591、AT24C02)

## 1.PCF8591

```c
uchar read_adc(uchar add)
{
	uchar temp; 
	EA=0;
	IIC_Start();
	IIC_SendByte(0x90);
	IIC_WaitAck();
	IIC_SendByte(add);
	IIC_WaitAck();
	IIC_Start();
	IIC_SendByte(0x91);
	IIC_WaitAck();
	temp=IIC_RecByte();
	IIC_WaitAck();
	IIC_Stop();	
	EA=1;
	return temp;
}

void write_adc(uchar add)
{
	IIC_Start();
	IIC_SendByte(0x90);
	IIC_WaitAck();
	IIC_SendByte(add);
	IIC_WaitAck();
	IIC_Stop();
}
```

## 2.AT24C02

```c
uchar read_24c02(uchar add)
{
	uchar temp;
	EA=0;
	IIC_Start();
	IIC_SendByte(0xa0);
	IIC_WaitAck();
	IIC_SendByte(add);
	IIC_WaitAck();
	IIC_Start();
	IIC_SendByte(0xa1);
	IIC_WaitAck();
	temp=IIC_RecByte();
	IIC_WaitAck();
	IIC_Stop();
	EA=1;
	return temp;
}

void write_24c02(uchar add,uchar date)
{
	EA=0;
	IIC_Start();
	IIC_SendByte(0xa0);
	IIC_WaitAck();
	IIC_SendByte(add);
	IIC_WaitAck();
	IIC_SendByte(date);
	IIC_WaitAck();
	IIC_Stop();
	EA=1;
}
```

