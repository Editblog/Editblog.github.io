# 一、实训平台介绍

## 1、实训平台布局

![](https://i.loli.net/2020/12/12/GLvQBxYMjIbczeP.jpg)![image-20201212200151324](https://i.loli.net/2020/12/12/iCwrKpEBJvtVkxG.png)

## 2、跳线帽说明

![image-20201212201215265](https://i.loli.net/2020/12/12/u2yZw5Fe4GbEQaJ.png)

## 3、电位器功能说明

![image-20201212201230347](https://i.loli.net/2020/12/12/tPqQc69IJmZTfbH.png)

## 4、输入输出接口

![ ](https://i.loli.net/2020/12/12/m1QbFfqpUYnGCSe.png)

![image-20201212201543030](https://i.loli.net/2020/12/12/rxDL1Ql43SMkVhH.png)

## 5、端口资源分配

![image-20201212201645090](https://i.loli.net/2020/12/12/34jQcSlDUegWhJr.png)

### (1)、单片机端口资源分配

![image-20201212202222329](https://i.loli.net/2020/12/12/YiKLBFe8M9PdpJT.png)

![image-20201212202236265](https://i.loli.net/2020/12/12/586FNAvIG2zgYbD.png)

![image-20201212202255282](https://i.loli.net/2020/12/12/TYxV3fIAWqRkLvd.png)

![image-20201212202517303](https://i.loli.net/2020/12/12/XTmR9CWyOS8pHsx.png)

### (2)、138译码器端口资源分配

![image-20201212202546122](https://i.loli.net/2020/12/12/xXBszSpwVqlDbG3.png)

![1](https://i.loli.net/2020/12/13/OFa2PdzpWRC13tH.png)

### (3)、锁存器端口资源分配

![image-20201212202637487](https://i.loli.net/2020/12/12/XvsGwH7FP5krVIo.png)

![image-20201212202650377](https://i.loli.net/2020/12/12/R3lP9ZfnBUgFDto.png)

### (4)、PCF8591输入端口资源分配

![image-20201212202702977](https://i.loli.net/2020/12/12/d79nwOu4rozg6Wa.png)

# 二、蜂鸣器

## 1、原理图

![image-20201213230033389](https://i.loli.net/2020/12/13/2ZixjpVKkHXJO6B.png)

## 2、代码

### (1)IO控制

```c
//简单粗暴
sbit buzzer=P0^6
P2 = 0xa0;
buzzer = 0;
P2 = 0x00;
```

```c
/*
&：与，作用是将某位置0
|：或，作用是将某位置1
且不影响其他位
*/
P2 = ((P2&0x1f)|0xa0);
P0 &= ~(0x01<<6);//关
//P0 |= (0x01<<6);//开
P2 &= 0x1f;
```

### (2)、MM控制（存储器映射）

![image-20201213232733660](https://i.loli.net/2020/12/13/6rxKMo2Yg9nRDWw.png)

```c
#include "reg52.h"
#include "absacc.h"
void main()
{
	XBYTE[0xA000] = 0x00;//关蜂鸣器
	while(1)
	{
	.......
	}
}
```

## 3、练习

### (1)、编程实现继电器控制

![image-20201214000629191](https://i.loli.net/2020/12/14/96feWsigypkuTVE.png)

```c
#include "STC15F2K60S2.h" 

sbit buzzer = P0^6;
sbit relay = P0^4;

void main()
{
	P2=0xa0;buzzer=0;P2=0x00;
	P2=0xa0;relay=1;P2=0x00;
	while(1)
	{
		
	}
}
```

### (2)、编程实现蜂鸣器间隔1秒响

（软件延时、定时器实现都可以）

```c
#include "STC15F2K60S2.h" 
#include "intrins.h"

sbit buzzer = P0^6;
sbit relay = P0^4;

void Delay1000ms()		//@11.0592MHz
{
	unsigned char i, j, k;

	_nop_();
	_nop_();
	i = 43;
	j = 6;
	k = 203;
	do
	{
		do
		{
			while (--k);
		} while (--j);
	} while (--i);
}


void main()
{
	P2=0xa0;buzzer=0;P2=0x00;
	P2=0xa0;relay=1;P2=0x00;
	while(1)
	{
		P2=0xa0;buzzer=0;P2=0x00;
		Delay1000ms();
		P2=0xa0;buzzer=1;P2=0x00;
		Delay1000ms();
	}
}
```

# 三、LED

## 1、原理图

![image-20201214002248600](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210207193509.png)

## 2、代码

### (1)、IO控制

```c
#include "STC15F2K60S2.h" 
#include "intrins.h"

void Delay200ms()		//@11.0592MHz
{
	unsigned char i, j, k;

	_nop_();
	_nop_();
	i = 9;
	j = 104;
	k = 139;
	do
	{
		do
		{
			while (--k);
		} while (--j);
	} while (--i);
}


void main()
{
	unsigned char i;
	while(1)
	{
		P2=0x80;P0=~(0x01<<i);P2=0x00;
		i++;
		if(i==8) i=0;
		Delay200ms();
	}
}




```

### (2)、MM控制



# 四、按键

![image-20210207195148284](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210207195148.png)

## 1.独立按键

### (1)状态机消抖

```C
//状态机消抖，可以用10ms延时查询，也可以用10ms中断查询，建议用中断
#define key_input P3
#define key_state_0 0	//判断按键是否按下
#define key_state_1 1	//判断按键是否抖动
#define key_state_2 2	//判断按键是否弹起
#define key_mask 0x0f	//屏蔽不需要的IO
char read_key()
{
	static key_state = 0;
	char key_press,key_return = 0;
	key_press = key_input & key_mask;
	switch(key_state)
	{
		case key_state_0:
			if(key_press != key_mask)
				key_state = key_state_1;
			break;
		
		case key_state_1:
			if(key_press != key_mask)
			{
				if(key_press == 0x0e) key_return = 1;	//S7
				if(key_press == 0x0d) key_return = 2;	//S6
				if(key_press == 0x0b) key_return = 3;	//S5
				if(key_press == 0x07) key_return = 4;	//S4
				key_state = key_state_2;
			}
			else
				key_state = key_state_0;
			break;
			
		case key_state_2:
			if(key_press == 0x0f) key_state = key_state_0;
			break;
	}
	return key_return;
}

//test
#include <STC15F2K60S2.H> 
#include "sys.h"

u8 Trg;	//触发
u8 Cont;	//持续
void main()
{
	u8 i=0;
	sys_init();
	while(1)
	{
		i = read_key();
		delay_ms(10);
		if(i == 1)
		{
			led_allon();
		}
		if(i == 2)
		{
			led_alloff();
		}
	}
		
}
```

### (2)三行代码消抖

```C
/*******************************************************
Name : key_read
Function :	(1) No Key :ReadDate=0;Trg=0;Cont=0
			(2) D0 is 0 : KEYPORT=0xfe;ReadDate=0x01;Trg = 0x01 & (0x01 ^ 0x00) = 0x01;Cont=0x01
			(3) when D0 is always 0 : Trg = 0x01 & (0x01 ^ 0x01) = 0x00;Cont=0x01
			(4) when D0 is 1 : Trg = 0x01 & (0x00 ^ 0x01) = 0;Cont=0
Example:
	if(Trg & 0x08)	//one key
	
	if(Cont & 0x08)	//long key
	{
		time_count++;
		if(time_count == 100)
		{
			time_count = 0;
			SendString(*long !\r\n);
		}
	}
*******************************************************/
extern u8 Trg;	//触发
extern u8 Cont;	//持续
void key_read()
{
	unsigned char ReadDate = KEYPORT ^ 0xff;	//ReadDate：读取的键值	^：异或	  
	Trg = ReadDate & (ReadDate ^ Cont);	//
	Cont = ReadDate;	//
}

//test
#include <STC15F2K60S2.H> 
#include "sys.h"

u8 Trg;	//触发
u8 Cont;	//持续
void main()
{
	u8 i=0;
	sys_init();
	while(1)
	{
		i = read_key();
		delay_ms(10);
		if(Trg & 0x0d)
		{
			led_allon();
		}
		if(Trg & 0x0e)
		{
			led_alloff();
		}
	}
		
}

```

## 2.矩阵按键

### 行列扫描法

先得出是哪一行的，再得出是哪一列的，如果先求列，P42与P44一直会被占用为高电平，不利于编程，会有一些bug存在

```C
#include "key.h"
#define key P3
u8 keyvalue=16;

u8 scan_key()
{
	key=0x0F;P42=0;P44=0;
	if(key!=0x0F)//说明没有按键下去  00001111
	{
		delay_ms(10);
		if(key!=0x0F)//说明没有按键下去
		{
			switch (key)
			{
				case(0x07):keyvalue=0;break;
				case(0x0b):keyvalue=1;break;
				case(0x0d):keyvalue=2;break;
				case(0x0e):keyvalue=3;break;
			}
		}
		key=0xF0;P42=1;P44=1;
		if(!P42) key=0xb0;
		if(!P44) key =0x70;
		if(key!=0xF0)
		{
			switch (key)
			{
				case(0x70):keyvalue +=0;break;
				case(0xb0):keyvalue +=4;break;
				case(0xd0):keyvalue +=8;break;
				case(0xe0):keyvalue +=12;break;
			}
		}
	}
	return keyvalue;
}

```



# 五、数码管

![image-20210207223330247](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210207223330.png)

## 1.单个数码管操作

### .h文件

```c
#ifndef __DISPALY_H__
#define __DISPALY_H__
#include "sys.h"
#define u8 unsigned char
#define u16 unsigned int
void display1(u8 yi,u8 er);
void display2(u8 san,u8 si);
void display3(u8 wu,u8 liu);
void display4(u8 qi,u8 ba);

#endif

```

### .c文件

```C
#include "display.h"
u8 code tab[]={                       //标准字库
//   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
    0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71,
//black  -     H    J    K    L    N    o   P    U     t    G    Q    r   M    y
    0x00,0x40,0x76,0x1E,0x70,0x38,0x37,0x5C,0x73,0x3E,0x78,0x3d,0x67,0x50,0x37,0x6e,
    0xBF,0x86,0xDB,0xCF,0xE6,0xED,0xFD,0x87,0xFF,0xEF,0x46};    //0. 1. 2. 3. 4. 5. 6. 7. 8. 9. -1

void display1(u8 yi,u8 er)
{
	P2=(P2&0x1f)|0xc0;//打开数码管位选573  U8
	P0=0X01;//选择第一个数码管
	P2=0XFF;//打开数码管段选573  U7
	P0=~tab[yi];//数码管显示码值
	delay_ms(1);
	 
	P2=(P2&0x1f)|0xc0;//打开数码管位选573  U8
	P0=0X02;//选择第一个数码管
	P2=0XFF;//打开数码管段选573  U7
	P0=~tab[er];//数码管显示码值
	delay_ms(1);
}
 
void display2(u8 san,u8 si)
{
	P2=(P2&0x1f)|0xc0;
	P0=0X04;
	P2=0XFF;
	P0=~tab[san];
	delay_ms(1);
	 
	P2=(P2&0x1f)|0xc0;
	P0=0X08;
	P2=0XFF;
	P0=~tab[si];
	delay_ms(1);
}
 
void display3(u8 wu,u8 liu)
{
	P2=(P2&0x1f)|0xc0;
	P0=0X10;
	P2=0XFF;
	P0=~tab[wu];
	delay_ms(1);
	 
	P2=(P2&0x1f)|0xc0;
	P0=0X20;
	P2=0XFF;
	P0=~tab[liu];
	delay_ms(1);
}
 
void display4(u8 qi,u8 ba)
{
	P2=(P2&0x1f)|0xc0;
	P0=0X40;
	P2=0XFF;
	P0=~tab[qi];
	delay_ms(1);
	 
	P2=(P2&0x1f)|0xc0;
	P0=0X80;
	P2=0XFF;
	P0=~tab[ba];
	delay_ms(1);

	P2=(P2&0x1f)|0xc0;
	P0=0XFF;
	P2=0XFF;
	P0=0XFF;
}
```

## 2.改良版

耗费一些空间，建立一个缓存区，将数值先放进缓存区，再通过定时器或者延时在固定时间内刷新一次

```C
#include "display.h"
u8 code tab[]={                       //标准字库
//   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
    0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71,
//black  -     H    J    K    L    N    o   P    U     t    G    Q    r   M    y
    0x00,0x40,0x76,0x1E,0x70,0x38,0x37,0x5C,0x73,0x3E,0x78,0x3d,0x67,0x50,0x37,0x6e,
    0xBF,0x86,0xDB,0xCF,0xE6,0xED,0xFD,0x87,0xFF,0xEF,0x46};    //0. 1. 2. 3. 4. 5. 6. 7. 8. 9. -1
u8 seg7_buf[]={10,10,17,10,10,17,10,10};

/*
	seg7set ： 将数值放到缓存中去
	@pos : 位选
	@index : 赋值的数值
*/
void seg7set(u8 pos,u8 index){
	seg7_buf[pos] = index;
}
/*
	seg7xx ：将数码管的第pos位显示为缓冲区的第index位
	@pos ： 数码管的第几位
	@index : 缓冲区的第几位
*/
void seg7xx(u8 pos,u8 index)
{
	P2 = (P2&0x1f)|0xC0;
	P0 = 1<<pos;
	P2 = P2&0x1f;

	P2 = (P2&0x1f)|0xE0;		
	P0 = ~tab[seg7_buf[index]];
	P2 = P2&0x1f;
}
```

main.c

```c
#include <STC15F2K60S2.h>
#include "sysinit.h"
#include "delay.h"
#include "LED.h"
#include "seg7.h"
u16 count=0;
u16 count10 = 0;

void main(void) {
	u16 s,min,h = 0;
	// 关闭外部设备
	Close_Buzzer();
	Led_Display(0xff);

	// 初始化中断
	Timer0Init();
	//	开启中断
	ET0 = 1;
	EA = 1;
	while(1){
		if(count10==100)
		{
			count10=0;
			s++;
		}
		// 秒
		seg7set(7,(s / 10) % 10);
		seg7set(6,s / 100);
		// 分
		if(s == 600){
			s = 0;
			min = min + 1;
		}
		seg7set(4,min % 10);
		seg7set(3,min / 10);
		// 时
		if(min == 60){
			min = 0;
			h = h + 1;
		}
		seg7set(1,h % 10);
		seg7set(0,h / 10);
	}

}

void isr_timer0() interrupt 1
{
	count++;
	count10++;
	if(count==8) count=0;
	seg7xx(count,count);
}
```

# 六、DS18B20

## 1.DS18B20温度传感器特性

![image-20210209161226879](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210209161234.png)

## 2.DS18B20常见封装形式与引进说明

![image-20210209161437679](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210209161437.png)

## 3、DS18B20硬件连接方式

### 1.外部电源供电方式（最常用的方式）

![image-20210209161555018](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210209161555.png)

### 2.寄生电源供电方式

![image-20210209161810987](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210209161811.png)

### 3.寄生电源强上拉供电方式

![image-20210209162133346](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210209162133.png)

## 4、与操作DS18B20有关的內部功能结构

![image-20210209163007766](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210209163007.png)

![image-20210209170316653](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210209170316.png)

![image-20210209170717199](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210209170717.png)

![image-20210209171354748](https://raw.githubusercontent.com/Editblog/PicGo/master/img/20210209171354.png)

# 七、IIC协议(PCF8591、AT24C02)

## 一、IIC协议介绍

### 1、总线启动

SCL为高电平时，SDA由高电平向低电平变化



![image-20210305000846089](https://raw.githubusercontent.com/Editblog/PicGo/main/img/20210305000846.png)

```c
//总线启动条件
void IIC_Start(void)
{
	SDA = 1;
	SCL = 1;
	somenop;
	SDA = 0;
	somenop;
	SCL = 0;	
}
```



### 2、总线停止

SCL为高电平时，SDA由低电平向高电平变化

![image-20210305000857274](https://raw.githubusercontent.com/Editblog/PicGo/main/img/20210305000857.png)

```c
//总线停止条件
void IIC_Stop(void)
{
	SDA = 0;
	SCL = 1;
	somenop;
	SDA = 1;
}
```



### 3、应答

应答信号：在SCL为高电平时，接受设备将SDA拉为低电平表示传输正确，产生应答，否则为非应答

![image-20210305001038499](https://raw.githubusercontent.com/Editblog/PicGo/main/img/20210305001038.png)

#### (1)应答位控制

```c
//应答位控制
void IIC_Ack(unsigned char ackbit)
{
	if(ackbit) 
	{	
		SDA = 0;
	}
	else 
	{
		SDA = 1;
	}
	somenop;
	SCL = 1;
	somenop;
	SCL = 0;
	SDA = 1; 
	somenop;
}
```

#### (2)等待应答

```C
//等待应答
bit IIC_WaitAck(void)
{
	SDA = 1;
	somenop;
	SCL = 1;
	somenop;
	if(SDA)    //非应答
	{   
		SCL = 0;
		IIC_Stop();
		return 0;
	}
	else  	//应答
	{ 
		SCL = 0;
		return 1;
	}
}
```

### 4、IIC总线数据位的有效性规定

IIC总线进行数据传送时，时钟信号SCL为高电平期间，数据线上的信号SDA必须保持稳定。只有SCL为低电平期间SDA上的电平才允许变化。因此在写数据时，要在SCL为低的时候改变SDA。读数据时要在SCL为高的时候读SDA

![image-20210305001318036](https://raw.githubusercontent.com/Editblog/PicGo/main/img/20210305001318.png)

#### (1)通过I2C总线发送数据

```c
//通过I2C总线发送数据
void IIC_SendByte(unsigned char byt)
{
	unsigned char i;
	for(i=0;i<8;i++)
	{   
		if(byt&0x80) 
		{	
			SDA = 1;
		}
		else 
		{
			SDA = 0;
		}
		somenop;
		SCL = 1;
		byt <<= 1;
		somenop;
		SCL = 0;
	}
}
```

#### (2)从I2C总线上接收数据

```C
//从I2C总线上接收数据
unsigned char IIC_RecByte(void)
{
	unsigned char da;
	unsigned char i;
	
	for(i=0;i<8;i++)
	{   
		SCL = 1;
		somenop;
		da <<= 1;
		if(SDA) 
		da |= 0x01;
		SCL = 0;
		somenop;
	}
	return da;
}
```

## 二、PCF8591编程

### 1、PCF8591地址定义

![image-20210305003826574](https://raw.githubusercontent.com/Editblog/PicGo/main/img/20210305003826.png)

### 2、PCF8591写时序

![image-20210305004434177](https://raw.githubusercontent.com/Editblog/PicGo/main/img/20210305004434.png)

```C
void write_adc(uchar add)
{
	IIC_Start();
	IIC_SendByte(0x90);
	IIC_WaitAck();
	IIC_SendByte(add);
	IIC_WaitAck();
	IIC_Stop();
}
```

### 3、PCF8591读时序

先告诉ADC要读哪个通道的数据，再把数据接收回来

![image-20210305004732247](https://raw.githubusercontent.com/Editblog/PicGo/main/img/20210305004732.png)

```c
uchar read_adc(uchar add)
{
	uchar temp; 
	EA=0;
	IIC_Start();
	IIC_SendByte(0x90);
	IIC_WaitAck();
	IIC_SendByte(add);
	IIC_WaitAck();
	IIC_Start();
	IIC_SendByte(0x91);
	IIC_WaitAck();
	temp=IIC_RecByte();
	IIC_WaitAck();
	IIC_Stop();	
	EA=1;
	return temp;
}
```

### 4、应用

```C
write_adc(0x01); // ch1
while(1)
{
    EA=0;
    adc_val=read_adc(0x01);
    EA=1;
    //通道1，光敏电阻
    //显示,T_display[adc_table[i]]
    adc_table[0]=adc_val/100;//bai
    adc_table[1]=adc_val/10%10;//shi
    adc_table[2]=adc_val%10;
    //通道3，测电压
    volt=adc_val/255.0f*5;
    volt_table[0]=T_display[(unsigned char)volt] | 0x80;//显示小数点，改变码值
    volt_table[1]=T_display[(unsigned char)(volt*10)%10];
    volt_table[2]=T_display[(unsigned char)(volt*100)%10];
    Delay2ms();
}
```



## 三、AT24C02编程

### 1、AT24C02写时序

![image-20210305005817689](https://raw.githubusercontent.com/Editblog/PicGo/main/img/20210305005817.png)

```c
void write_24c02(uchar add,uchar date)
{
	EA=0;
	IIC_Start();
	IIC_SendByte(0xa0);
	IIC_WaitAck();
	IIC_SendByte(add);
	IIC_WaitAck();
	IIC_SendByte(date);
	IIC_WaitAck();
	IIC_Stop();
	EA=1;
}
```

### 2、AT24C02读时序

![image-20210305005929958](https://raw.githubusercontent.com/Editblog/PicGo/main/img/20210305005930.png)

```c
uchar read_24c02(uchar add)
{
	uchar temp;
	EA=0;
	IIC_Start();
	IIC_SendByte(0xa0);
	IIC_WaitAck();
	IIC_SendByte(add);
	IIC_WaitAck();
	IIC_Start();
	IIC_SendByte(0xa1);
	IIC_WaitAck();
	temp=IIC_RecByte();
	IIC_WaitAck();
	IIC_Stop();
	EA=1;
	return temp;
}
```

### 3、应用

```c
open_num =read_24c02(0x55);
write_24c02(0x55,++open_num);
open_num_table[0]=T_display[open_num/10];
open_num_table[1]=T_display[open_num%10];
```

# 八、.SPI协议(DS1302)

## 一、DS1302电路图

![image-20210304220458241](https://raw.githubusercontent.com/Editblog/PicGo/main/img/20210304220458.png)

## 二、SPI协议介绍

### 1、单字节写入一字节数据

![image-20210304220652122](https://raw.githubusercontent.com/Editblog/PicGo/main/img/20210304220652.png)

```C
/*单字节写入一字节数据*/
void Write_Ds1302_Byte(unsigned char dat) 
{
	unsigned char i;
	SCK = 0;
	for (i=0;i<8;i++) 
	{ 
		if (dat & 0x01) 	// 等价于if((addr & 0x01) ==1) 
		{
			SDA_SET;		//#define SDA_SET SDA=1 /*电平置高*/
		}
		else 
		{
			SDA_CLR;		//#define SDA_CLR SDA=0 /*电平置低*/
		}		 
		SCK_SET;
		SCK_CLR;		
		dat = dat >> 1; 
	} 
}
```



### 2、单字节读出一字节数据

![image-20210304220708091](https://raw.githubusercontent.com/Editblog/PicGo/main/img/20210304220708.png)

```C
/*单字节读出一字节数据*/
unsigned char Read_Ds1302_Byte(void) 
{
	unsigned char i, dat=0;	
	for (i=0;i<8;i++)
	{	
		dat = dat >> 1;
		if (SDA_R) 	  //等价于if(SDA_R==1)    #define SDA_R SDA /*电平读取*/	
		{
			dat |= 0x80;
		}
		else 
		{
			dat &= 0x7F;
		}
		SCK_SET;
		SCK_CLR;
	}
	SDA_CLR;
	return dat;
}
```

### 3、向DS1302 单字节写入一字节数据

![image-20210304220652122](https://raw.githubusercontent.com/Editblog/PicGo/main/img/20210304220652.png)

```c
/*向DS1302 单字节写入一字节数据*/
void Ds1302_Single_Byte_Write(unsigned char addr, unsigned char dat)
{ 

	RST_CLR;			/*RST脚置低，实现DS1302的初始化*/
	SCK_CLR;			/*SCK脚置低，实现DS1302的初始化*/

	RST_SET;			/*启动DS1302总线,RST=1电平置高 */
	addr = addr & 0xFE;	 
	Write_Ds1302_Byte(addr); /*写入目标地址：addr,保证是写操作,写之前将最低位置零*/	
	Write_Ds1302_Byte(dat);	 /*写入数据：dat*/
	RST_CLR;				 /*停止DS1302总线*/
}
```



### 4、从DS1302单字节读出一字节数据

![image-20210304220708091](https://raw.githubusercontent.com/Editblog/PicGo/main/img/20210304220708.png)

```c
/*从DS1302单字节读出一字节数据*/
unsigned char Ds1302_Single_Byte_Read(unsigned char addr) 
{ 
	unsigned char temp;
	RST_CLR;			/*RST脚置低，实现DS1302的初始化*/
	SCK_CLR;			/*SCK脚置低，实现DS1302的初始化*/

	RST_SET;	/*启动DS1302总线,RST=1电平置高 */	
	addr = addr | 0x01;	 
	Write_Ds1302_Byte(addr); /*写入目标地址：addr,保证是读操作,写之前将最低位置高*/
	temp=Read_Ds1302_Byte(); /*从DS1302中读出一个字节的数据*/		
	RST_CLR;	/*停止DS1302总线*/
	return temp;
}
```

## 三、DS1302编程

![image-20210304231254265](https://raw.githubusercontent.com/Editblog/PicGo/main/img/20210304231254.png)

```c
/**
  * @brief  无需更改延时
  * @param  shi,fen,miao
  * @retval None
  * @author dianshe.taobao.com
  */
void set_sfm(char shi,char fen,char miao)
{
	Ds1302_Single_Byte_Write(0x8e,0);							//关闭写保护
	Ds1302_Single_Byte_Write(0x80,(miao/10)*16+miao%10);		//以BCD码写入秒数据
	Ds1302_Single_Byte_Write(0x82,(fen/10)*16+fen%10);			//以BCD码写入分数据
	Ds1302_Single_Byte_Write(0x84,(shi/10)*16+shi%10);			//以BCD码写入时数据
	Ds1302_Single_Byte_Write(0x8e,0x80);						//打开写保护
}

/************************************************/
shi=Ds1302_Single_Byte_Read(0x85); //BCD码
miao=Ds1302_Single_Byte_Read(0x81);
fen=Ds1302_Single_Byte_Read(0x83);
/************************************************/

/************************************************/
unsigned char time_table[10];

EA=0;
shi=Ds1302_Single_Byte_Read(0x85); //BCD?
miao=Ds1302_Single_Byte_Read(0x81);
fen=Ds1302_Single_Byte_Read(0x83);
EA=1;
time_table[0]=shi/16;
time_table[1]=shi%16;
time_table[2]=10;
time_table[3]=fen/16;
time_table[4]=fen%16;
time_table[5]=10;
time_table[6]=miao/16;
time_table[7]=miao%16;
/************************************************/
```

# 九、寄存器

## 1、辅助特殊功能寄存器：AUXR

![image-20210304083454997](https://raw.githubusercontent.com/Editblog/PicGo/main/img/20210304084153.png)

## 2、中断允许寄存器IE

![image-20210304084727549](https://raw.githubusercontent.com/Editblog/PicGo/main/img/20210304084746.png)

## 3、中断优先级控制寄存器IP

![image-20210304084859732](https://raw.githubusercontent.com/Editblog/PicGo/main/img/20210304084859.png)

## 4、定时器/计数器控制寄存器 TCON

![image-20210304085003205](https://raw.githubusercontent.com/Editblog/PicGo/main/img/20210304085003.png)

## 5、中断函数的一般形式

![image-20210304085056836](https://raw.githubusercontent.com/Editblog/PicGo/main/img/20210304085056.png)

